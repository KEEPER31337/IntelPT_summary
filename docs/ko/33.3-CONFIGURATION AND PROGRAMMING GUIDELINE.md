# 33.3 CONFIGURATION AND PROGRAMMING GUIDELINE

## 33.3.1 Detection of Intel Processor Trace and Capability Enumeration

Intel PT를 위한 프로세서 지원은 CPUID로 표시됩니다.(EAX=07H,ECX=0H):EBX[bit 25] = 1. CPUID 기능 14H는 CPUID를 보고하는 프로세서의 자원과 기능을 열거하는 전용 기능입니다.(EAX=07H,ECX=0H):EBX[bit 25] = 1. 다른 프로세서 세대는 구조적으로 정의된 기능의 차이가 있을 수 있습니다. 표 33-11은 Intel PT를 지원하는 프로세서 세대에서 소프트웨어가 사용해야하는 열거 가능한 기능들의 세부사항을 설명합니다.

만약 CPUID가 0이 아닌 값을 보고한다면, Intel PT의 추가적인 기능들은 CPUID leaf 14H의 하위 leaves에 설명되어 있습니다.

### 33.3.1.1 Packet Decoding of RIP versus LIP

FUP, TIP, TIP.PGE, 그리고 TIP.PGE 패킷들은 명령 포인터(IP) 페이로드를 포함할 수 있습니다. 일부 프로세서 세대에서는 이 페이로드가 유효 주소(RIP)가 되는 반면, 다른 프로세서 세대에서는 선형 주소가 됩니다. 전자의 경우, 페이로드는 현재의 CS베이스 어드레스로부터의 오프셋이며, 반면에 후자의 경우는 오프셋과 CS 베이스 어드레스의 합입니다.(실모드에서는 CS베이스 어드레스는 CS << 4의 값이며, 보호모드에서는 CS 베이스 어드레스는 CS 레지스터가 나타내는 세그먼트의 베이스 선형 어드레스입니다.) 어떤 IP 타입이 사용되고 있는지는 열거형으로 나타냅니다(표 33-11의 CPUID.(EAX=14H, ECX=0):ECX.LIP[bit 31] 참조).

CS 기본 주소가 0인 상태에서 실행되는 소프트웨어의 경우(64비트 모드로 실행되는 모든 소프트웨어 포함) 그 차이를 구별할 수 없습니다. 트레이스 디코더는 CS 기본 주소가 0이 아니고 RIP의 사용을 열거하는 CPU에서 생성된 트레이스에서 해결된 LIP가 분명하지 않은 경우를 고려해야 합니다. 이로 인해 트레이스를 연관된 바이너리와 연결하려고 할 때 문제가 발생할 가능성이 높습니다.

IP 필터링 및 TraceStop 범위 계산의 경우 IP 비교 로직은 이러한 IP 패킷과 동일한 IP 유형을 기반으로 합니다. RIP를 출력하는 프로세서의 경우 IP 비교 메커니즘도 RIP를 기반으로 하므로 해당 프로세서에 RIP 값을 IA32_RTIT_ADDRn_[AB] MSR에 기록해야 합니다. 이는 서로 다른 IP 유형, 즉 CPUID.(EAX=14H, ECX=0):ECX.LIP[bit 31] 를 보고하는 프로세서에서 동일한 트레이스 구성 설정을 실행할 경우 다른 동작을 생성할 수 있습니다. IP 필터를 구성할 때 CPUID를 확인하려면 주의해야 합니다.

### 33.3.1.2

일부 프로세서 세대에서는 소프트웨어가 인텔 프로세서 트레이스로 추적을 활성화했을 때 LBR/BTS/BTM/LER을 사용하지 못하도록 제한을 가합니다. 이 프로세서에서 TraceEn이 설정되면 LBR, BTS, BTM, LER의 업데이트는 일시 중단되지만 해당 IA32_DEBUGCTL 컨트롤 필드의 상태는 여전히 활성화된 것처럼 변경되지 않았습니다. TraceEn이 지워지면 LBR 어레이가 재설정되고 LBR/BTS/BTM/LER의 업데이트가 재개됩니다. 또한 이 레지스터의 읽기는 0으로 반환되고 쓰기는 삭제됩니다.

업데이트/접근이 제한되는 MSR목록은 다음과 같습니다.

+ MSR_LASTBRANCH_x_TO_IP, MSR_LASTBRANCH_x_FROM_IP, MSR_LBR_INFO_x, MSR_LASTBRANCH_TOS
+ MSR_LER_FROM_LIP, MSR_LER_TO_LIP
+ MSR_LBR_SELECT

CPUID DisplayFamily_DisplayModel 서명이 06_3DH, 06_47H, 06_4EH, 06_4FH, 06_56H 및 06_5EH인 프로세서의 경우 Intel PT 및 LBR의 사용은 상호 배타적입니다.

## 33.3.2 Enabling and Configuration of Trace Packet Generation

추적 패킷을 구성하고 패킷 생성을 활성화하며 패킷을 캡처하기 위해 소프트웨어는 CPUID 명령을 사용하여 해당 피쳐 플래그인 CPUID.(EAX=07H, ECX=0H):EBX[bit 25] = 1 를 검출하는 것으로 시작합니다. 섹션 33.3.1에 설명된 기능들을 열거함으로써 덧붙입니다.

섹션 33.3.1에서 조회한 기능을 기반으로 소프트웨어는 여러 모델별 레지스터를 구성해야 합니다. 이 섹션에서는 해당 MSR과 관련된 프로그래밍 고려 사항에 대해 설명합니다.

### 33.3.2.1 Enabling Packet Generation

패킷 생성을 구성하고 사용하도록 설정할 때 다른 구성 MSR에 기록하면 TraceEn = 1인 경우 일반 보호 오류(#GP)가 발생하므로 다른 Intel PT MSR이 기록된 후에 IA32_RTIT_CTL MSR을 기록해야 합니다. 이전 추적 수집 컨텍스트를 복원하지 않는 경우 소프트웨어에서 먼저 IA32_RTIT_STATUS를 지워야 합니다. Stopped 및 Error 필드를 기록할 수 있으므로; MSR을 지우는 것은 이전 트레이스 패킷 수집 컨텍스트에서 지속되었을 수 있는 값을 지웁니다. TraceEn을 1로 설정하여 생성된 패킷에 대한 자세한 내용은 섹션 33.2.8.2를 참조하십시오.

TraceEn을 1로 설정하면 작동 오류가 발생할 수 있습니다(섹션 33.3.10 참조). 오류가 IA32_RTIT_STATUS MSR에 시그널링되기 전에 WRMSR이 완료된 후에 지연이 발생할 수 있습니다.

패킷 생성이 활성화되어 있는 동안 일부 구성 MSR(예: IA32_RTIT_STATUS 및 IA32_RTIT_OUT_*)의 값은 일시적이며 읽기는 오래된 값을 반환할 수 있습니다. 패킷 생성이 비활성화된 후에만(TraceEn을 지움) 이러한 MSR의 읽기는 신뢰할 수 있는 값을 반환합니다.

### 33.3.2.2 Disabling Packet Generation

+ Error 비트가 설정되어 있으면 운영상의 오류가 발생하여 트레이스가 손상되었을 가능성이 높습니다. 소프트웨어는 (출력 MSR 값을 검사하여) 오류의 원인을 확인하고 문제의 원인을 수정한 다음, 트레이스를 다시 수집하려고 시도해야 합니다. 작동 오류에 대한 자세한 내용은 섹션 33.3.10을 참조하십시오. 소프트웨어는 패킷 생성을 다시 활성화하기 전에 IA32_RTIT_STATUS.Error를 지워야 합니다.

+ Stopped 비트가 설정된 경우, 패킷 생성이 비활성화되기 전에 소프트웨어 실행에서 IP TraceStop(섹션 33.2.5.3 참조) 또는 ToPA Stop 조건(섹션 33.2.7.2의 "ToPA STOP" 참조)이 발생했습니다.

## 33.3.3 Flushing Trace Output

패킷은 먼저 내부적으로 버퍼링된 후 비동기적으로 기록됩니다. 후처리를 위해 패킷 출력을 수집하기 위해 수집기는 먼저 모든 패킷 데이터가 내부 버퍼에서 플러시되었는지 확인해야 합니다. 소프트웨어는 IA32_RTIT_CTL.TraceEn을 지움으로써 패킷 생성을 중지해 이를 보장할 수 있습니다(섹션 33.2.8.2의 "패킷 생성 비활성화" 참조).

소프트웨어가 내부 버퍼링된 패킷을 플러시하기 위해 IA32_RTIT_CTL.TraceEn을 삭제하면 논리 프로세서는 WC 트레이스 출력 저장소가 다음 저장소에 대해 순서대로 정렬되도록 하는 SFENCE 작업을 실행하거나 직렬화 작업을 수행합니다. 동일한 논리 프로세서의 후속 읽기에서는 플러시된 트레이스 데이터가 표시되고 다른 논리 프로세서의 읽기 전에 저장소, 펜스 또는 추적 논리 프로세서의 구조적 직렬화 작업이 수행되어야 합니다.

플러시 작업이 완료되면 IA32_RTIT_OUTL_* MSR 값은 트레이스가 종료된 위치를 나타냅니다. TraceEn이 설정되어 있는 동안 이러한 MSR은 오래된 값을 유지할 수 있습니다. 또한 INT=1인 ToPA 영역이 채워지면 ToPA PMI가 트리거된 경우 IA32_PERF_GLOBAL_STATUS.Trace_ToPA_PMI[55]는 플러시가 완료될 때까지 설정됩니다.

## 33.3.4 Warm Reset

Intel Processor Trace를 프로그래밍하는 데 사용되는 MSR 소프트웨어는 power-on RESET(또는 cold RESET)후에 지워집니다. warm RESET에서는 IA32_RTIT_CTL.TraceEn이 지워지는 것을 제외하고는 해당 MSR의 내용이 warm RESET 이전의 값을 유지할 수 있습니다(IA32_RTIT_STATUS의 일부 비트가 지워지는 부작용이 있을 수 있음).
# 33.3 CONFIGURATION AND PROGRAMMING GUIDELINE

## 33.3.1 Detection of Intel Processor Trace and Capability Enumeration

Intel PT를 위한 프로세서 지원은 CPUID로 표시됩니다.(EAX=07H,ECX=0H):EBX[bit 25] = 1. CPUID 기능 14H는 CPUID를 보고하는 프로세서의 자원과 기능을 열거하는 전용 기능입니다.(EAX=07H,ECX=0H):EBX[bit 25] = 1. 다른 프로세서 세대는 구조적으로 정의된 기능의 차이가 있을 수 있습니다. 표 33-11은 Intel PT를 지원하는 프로세서 세대에서 소프트웨어가 사용해야하는 열거 가능한 기능들의 세부사항을 설명합니다.

만약 CPUID가 0이 아닌 값을 보고한다면, Intel PT의 추가적인 기능들은 CPUID leaf 14H의 하위 leaves에 설명되어 있습니다.

### 33.3.1.1 Packet Decoding of RIP versus LIP

FUP, TIP, TIP.PGE, 그리고 TIP.PGE 패킷들은 명령 포인터(IP) 페이로드를 포함할 수 있습니다. 일부 프로세서 세대에서는 이 페이로드가 유효 주소(RIP)가 되는 반면, 다른 프로세서 세대에서는 선형 주소가 됩니다. 전자의 경우, 페이로드는 현재의 CS베이스 어드레스로부터의 오프셋이며, 반면에 후자의 경우는 오프셋과 CS 베이스 어드레스의 합입니다.(실모드에서는 CS베이스 어드레스는 CS << 4의 값이며, 보호모드에서는 CS 베이스 어드레스는 CS 레지스터가 나타내는 세그먼트의 베이스 선형 어드레스입니다.) 어떤 IP 타입이 사용되고 있는지는 열거형으로 나타냅니다(표 33-11의 CPUID.(EAX=14H, ECX=0):ECX.LIP[bit 31] 참조).

CS 기본 주소가 0인 상태에서 실행되는 소프트웨어의 경우(64비트 모드로 실행되는 모든 소프트웨어 포함) 그 차이를 구별할 수 없습니다. 트레이스 디코더는 CS 기본 주소가 0이 아니고 RIP의 사용을 열거하는 CPU에서 생성된 트레이스에서 해결된 LIP가 분명하지 않은 경우를 고려해야 합니다. 이로 인해 트레이스를 연관된 바이너리와 연결하려고 할 때 문제가 발생할 가능성이 높습니다.

IP 필터링 및 TraceStop 범위 계산의 경우 IP 비교 로직은 이러한 IP 패킷과 동일한 IP 유형을 기반으로 합니다. RIP를 출력하는 프로세서의 경우 IP 비교 메커니즘도 RIP를 기반으로 하므로 해당 프로세서에 RIP 값을 IA32_RTIT_ADDRn_[AB] MSR에 기록해야 합니다. 이는 서로 다른 IP 유형, 즉 CPUID.(EAX=14H, ECX=0):ECX.LIP[bit 31] 를 보고하는 프로세서에서 동일한 트레이스 구성 설정을 실행할 경우 다른 동작을 생성할 수 있습니다. IP 필터를 구성할 때 CPUID를 확인하려면 주의해야 합니다.

### 33.3.1.2

일부 프로세서 세대에서는 소프트웨어가 인텔 프로세서 트레이스로 추적을 활성화했을 때 LBR/BTS/BTM/LER을 사용하지 못하도록 제한을 가합니다. 이 프로세서에서 TraceEn이 설정되면 LBR, BTS, BTM, LER의 업데이트는 일시 중단되지만 해당 IA32_DEBUGCTL 컨트롤 필드의 상태는 여전히 활성화된 것처럼 변경되지 않았습니다. TraceEn이 지워지면 LBR 어레이가 재설정되고 LBR/BTS/BTM/LER의 업데이트가 재개됩니다. 또한 이 레지스터의 읽기는 0으로 반환되고 쓰기는 삭제됩니다.

업데이트/접근이 제한되는 MSR목록은 다음과 같습니다.

+ MSR_LASTBRANCH_x_TO_IP, MSR_LASTBRANCH_x_FROM_IP, MSR_LBR_INFO_x, MSR_LASTBRANCH_TOS
+ MSR_LER_FROM_LIP, MSR_LER_TO_LIP
+ MSR_LBR_SELECT

CPUID DisplayFamily_DisplayModel 서명이 06_3DH, 06_47H, 06_4EH, 06_4FH, 06_56H 및 06_5EH인 프로세서의 경우 Intel PT 및 LBR의 사용은 상호 배타적입니다.

## 33.3.2 Enabling and Configuration of Trace Packet Generation

추적 패킷을 구성하고 패킷 생성을 활성화하며 패킷을 캡처하기 위해 소프트웨어는 CPUID 명령을 사용하여 해당 피쳐 플래그인 CPUID.(EAX=07H, ECX=0H):EBX[bit 25] = 1 를 검출하는 것으로 시작합니다. 섹션 33.3.1에 설명된 기능들을 열거함으로써 덧붙입니다.

섹션 33.3.1에서 조회한 기능을 기반으로 소프트웨어는 여러 모델별 레지스터를 구성해야 합니다. 이 섹션에서는 해당 MSR과 관련된 프로그래밍 고려 사항에 대해 설명합니다.

### 33.3.2.1 Enabling Packet Generation

패킷 생성을 구성하고 사용하도록 설정할 때 다른 구성 MSR에 기록하면 TraceEn = 1인 경우 일반 보호 오류(#GP)가 발생하므로 다른 Intel PT MSR이 기록된 후에 IA32_RTIT_CTL MSR을 기록해야 합니다. 이전 추적 수집 컨텍스트를 복원하지 않는 경우 소프트웨어에서 먼저 IA32_RTIT_STATUS를 지워야 합니다. Stopped 및 Error 필드를 기록할 수 있으므로; MSR을 지우는 것은 이전 트레이스 패킷 수집 컨텍스트에서 지속되었을 수 있는 값을 지웁니다. TraceEn을 1로 설정하여 생성된 패킷에 대한 자세한 내용은 섹션 33.2.8.2를 참조하십시오.

TraceEn을 1로 설정하면 작동 오류가 발생할 수 있습니다(섹션 33.3.10 참조). 오류가 IA32_RTIT_STATUS MSR에 시그널링되기 전에 WRMSR이 완료된 후에 지연이 발생할 수 있습니다.

패킷 생성이 활성화되어 있는 동안 일부 구성 MSR(예: IA32_RTIT_STATUS 및 IA32_RTIT_OUT_*)의 값은 일시적이며 읽기는 오래된 값을 반환할 수 있습니다. 패킷 생성이 비활성화된 후에만(TraceEn을 지움) 이러한 MSR의 읽기는 신뢰할 수 있는 값을 반환합니다.

### 33.3.2.2 Disabling Packet Generation

+ Error 비트가 설정되어 있으면 운영상의 오류가 발생하여 트레이스가 손상되었을 가능성이 높습니다. 소프트웨어는 (출력 MSR 값을 검사하여) 오류의 원인을 확인하고 문제의 원인을 수정한 다음, 트레이스를 다시 수집하려고 시도해야 합니다. 작동 오류에 대한 자세한 내용은 섹션 33.3.10을 참조하십시오. 소프트웨어는 패킷 생성을 다시 활성화하기 전에 IA32_RTIT_STATUS.Error를 지워야 합니다.

+ Stopped 비트가 설정된 경우, 패킷 생성이 비활성화되기 전에 소프트웨어 실행에서 IP TraceStop(섹션 33.2.5.3 참조) 또는 ToPA Stop 조건(섹션 33.2.7.2의 "ToPA STOP" 참조)이 발생했습니다.

## 33.3.3 Flushing Trace Output

패킷은 먼저 내부적으로 버퍼링된 후 비동기적으로 기록됩니다. 후처리를 위해 패킷 출력을 수집하기 위해 수집기는 먼저 모든 패킷 데이터가 내부 버퍼에서 플러시되었는지 확인해야 합니다. 소프트웨어는 IA32_RTIT_CTL.TraceEn을 지움으로써 패킷 생성을 중지해 이를 보장할 수 있습니다(섹션 33.2.8.2의 "패킷 생성 비활성화" 참조).

소프트웨어가 내부 버퍼링된 패킷을 플러시하기 위해 IA32_RTIT_CTL.TraceEn을 삭제하면 논리 프로세서는 WC 트레이스 출력 저장소가 다음 저장소에 대해 순서대로 정렬되도록 하는 SFENCE 작업을 실행하거나 직렬화 작업을 수행합니다. 동일한 논리 프로세서의 후속 읽기에서는 플러시된 트레이스 데이터가 표시되고 다른 논리 프로세서의 읽기 전에 저장소, 펜스 또는 추적 논리 프로세서의 구조적 직렬화 작업이 수행되어야 합니다.

플러시 작업이 완료되면 IA32_RTIT_OUTL_* MSR 값은 트레이스가 종료된 위치를 나타냅니다. TraceEn이 설정되어 있는 동안 이러한 MSR은 오래된 값을 유지할 수 있습니다. 또한 INT=1인 ToPA 영역이 채워지면 ToPA PMI가 트리거된 경우 IA32_PERF_GLOBAL_STATUS.Trace_ToPA_PMI[55]는 플러시가 완료될 때까지 설정됩니다.

## 33.3.4 Warm Reset

Intel Processor Trace를 프로그래밍하는 데 사용되는 MSR 소프트웨어는 power-on RESET(또는 cold RESET)후에 지워집니다. warm RESET에서는 IA32_RTIT_CTL.TraceEn이 지워지는 것을 제외하고는 해당 MSR의 내용이 warm RESET 이전의 값을 유지할 수 있습니다(IA32_RTIT_STATUS의 일부 비트가 지워지는 부작용이 있을 수 있음).

## 33.3.5 Context Switch Consideration

소프트웨어 프로세스 또는 스레드 컨텍스트의 세분화된 명령어 실행 트레이스의 구축을 용이하게 하기 위해 소프트웨어는 프로세스 또는 스레드 컨텍스트 스위치 경계에 걸쳐 트레이스 구성 MSR의 상태를 저장하고 복원할 수 있습니다. 이 원리는 컨텍스트 스위치에 걸쳐 일반적인 아키텍처 프로세서 상태를 저장하고 복원하는 것과 같습니다.

### 33.3.5.1 Manual Trace Configuration Context Switch

구성은 RDMSR, MSR 내용 관리 및 WRMSR의 일련의 명령을 통해 저장 및 복원할 수 있습니다. 트레이싱을 중지하고 모든 구성 MSR에 안정적인 값이 포함되도록 하려면 소프트웨어가 다른 추적 구성 MSR을 읽기 전에 IA32_RTIT_CTL.TraceEn을 지워야 합니다. 추적 구성 컨텍스트를 수동으로 저장하는 권장 방법은 다음과 같습니다:

1. RDMSR IA32_RTIT_CTL, 값을 메모리에 저장
2. 위 RDMSR에서 저장된 값이 있는 WRMSR IA32_RTIT_CTL과 TraceEn이 지워짐
3. RDMSR  이전에 저장된 값에서 값이 변경된 다른 모든 구성 MSR, 변경된 값을 메모리에 저장

트레이스 구성 컨텍스트를 복원할 때 IA32_RTIT_CTL은 마지막으로 복원돼야 합니다:

1. IA32_RTIT_CTL을 제외한 저장된 구성 MSR 값을 메모리에서 읽고 WRMSR로 복원한다
2. 메모리에서 저장된 IA32_RTIT_CTL 값을 읽고 WRMSR로 복원합니다.

### 33.3.5.2 Trace Configuration Context Switch Using XSAVES/XRSTORS

XSAVE 기능 집합이 XSAVE 및 XRSTORS를 지원하는 프로세서에서는 XSAVE를 사용하여 Trace 구성 상태를 저장하고 XRSTORS에 의해 IA32_XSS의 감독 상태 구성 요소와 관련된 비트 필드와 함께 복원할 수 있습니다. Intel® 64의 13장 "XSAVE 기능 집합을 사용하여 상태 관리 ‚" 및 IA-32 Architectures Software Developer's Manual, Volume 1을 참조하십시오.

## 33.3.6 Cycle-Accurate Mode

Intel PT는 프로세서 코어 클럭 도메인에서 낮은 수준의 정보를 제공하는 CYC 패킷(섹션 33.4.2.14 참조)을 가능하게 하는 cycle-accurate 모드로 실행될 수 있습니다. CYC 패킷의 이 사이클 카운터 데이터는 IPC(Instructions Per Cycle)를 계산하거나 세밀한 수준의 월-클럭 시간을 추적하는 데 사용될 수 있습니다.

cycle-accurate 모드 패킷 생성을 활성화하려면, 소프트웨어에서  IA32_RTIT_CTL.CYCEn=1 을 설정해야 합니다. cycle-accurate 모드를 사용할 때는 언제든지 소프트웨어에서 TSCEn=1을 설정하는 것이 좋습니다. 이를 사용하면 모든 CYC 지원 패킷 보다 마지막 CYC 패킷 이후 코어 클럭 사이클의 수를 나타내는 페이로드인 CYC 패킷이 앞에 올 것입니다. 하나의 사이클에서 여러 개의 CYC 지원 패킷이 생성되는 경우, CYC 지원 패킷이 생성되기 전에 단일 CYC만 생성되고, 그렇지 않으면 각 CYC 지원 패킷이 자체 CYC보다 앞에 올 것입니다. CYC 지원 패킷은 다음과 같습니다:

+ TNT, TIP, TIP.PGE, TIP.PGD, MODE.EXEC, MODE.TSX, PIP, VMCS, OVF, MTC, TSC, PTWRITE, EXSTOP

TSC 패킷은 추적이 비활성화되어 있어 wall-clock 시간을 재구성하기에 충분한 정보가 없을 때(TriggerEn=0) 생성되거나 딥-슬립 MWAIT C-상태로의 전환과 같은 전원 차단 시나리오가 발생합니다. 이 경우 TSC와 함께 생성되는 CYC는 마지막 CYC 패킷과 TSC 패킷 사이에 실행된 활성 추적(전원이 켜진 사이클, TriggerEn=1) 횟수를 나타냅니다. 따라서 추적이 비활성 상태에서 소요되는 시간은 CYC 값을 기반으로 예상되는 시간과 TSC가 나타내는 실제 시간 사이의 시간 차이에서 추론할 수 있습니다.

추가적인 CYC 패킷은 독립형으로 전송될 수 있으므로, 프로세서는 디코더가 내부 하드웨어 카운터 랩 전에 경과한 사이클 수를 인식하거나 다른 마이크로아키텍처 상태로 인해 재설정되도록 보장할 수 있습니다. 이러한 독립형 CYC 패킷은 랩이 발생하기 전에 전송된다는 것 외에는 어느 간격으로 전송될지 보장되지 않습니다. 아래에 예시가 나와 있습니다.

### 33.3.6.1 Cycle Counter

사이클 카운터는 하드웨어로 구현되며(타임 스탬프 카운터 또는 성능 모니터링 카운터와 무관함), 포화되지 않고 오히려 랩이 되는 단순 증분 카운터입니다. 카운터의 크기는 구현에 따라 다릅니다.

TriggerEn이 지워지고 CYC 패킷이 전송될 때마다 사이클 카운터가 0으로 재설정됩니다. ContextEn 또는 FilterEn이 지워지면 주기 카운터가 계속 카운트되며 주기 패킷은 계속 생성됩니다. 절전 모드 상태에서는 Intel PT 로직의 전원이 꺼지는 카운트가 되지 않지만 클럭이 비활성화된 지점까지 카운트되고 다시 활성화되면 카운트가 재개됩니다.

### 33.3.6.2 Cycle Packet Semantics

Cycle-accurate 모드는 다음 프로토콜을 준수합니다:

+ CYC 패킷 이전의 모든 패킷은 CYC 시간 이전에 발생한 지시 또는 이벤트를 나타냅니다.
+ CYC 패킷을 따르는 모든 패킷은 CYC 시간과 동일한 시간 또는 그 이후에 발생한 지시 또는 이벤트를 나타냅니다.
+ CYC 패킷 바로 뒤에 오는 CYC 지원 패킷은 CYC 시간과 동시에 발생한 명령 또는 이벤트를 나타냅니다.

위의 이러한 항목들은 디코더에게 어셈블리 스트림의 특정 명령어에 CYC 패킷을 적용하는 수단을 제공합니다. 대부분의 패킷은 단일 명령 또는 이벤트를 나타내므로 각 패킷에 선행하는 CYC 패킷은 해당 명령 또는 이벤트의 폐기 시간을 나타냅니다. TNT 패킷의 경우, 최대 6개의 조건부 브랜치 및/또는 압축 RET가 패킷에 포함될 수 있습니다. 이 경우, 앞의 CYC 패킷은 패킷 내 첫 번째 브랜치의 폐기 시간을 제공합니다. 여러 지점이 TNT의 첫 번째 지점과 동일한 주기로 폐기되었을 수 있지만 프로토콜은 이를 명확하게 하지 않습니다. 또한, MTC 패킷은 TNT 패킷의 첫 번째 JCC와 동일한 주기로 생성될 수 있습니다. 이 경우, CYC는 MTC와 TNT 모두에 선행하며, 둘 다에 적용됩니다.

Cycle-accurate 모드가 활성화되어 있지만 사이클 카운터가 카운트를 중지하는 경우가 있습니다. 그러한 시나리오 이후에, CYC 패킷과 TSC 패킷이 전송될 것입니다. 페이로드 값을 해석하는 방법에 대해서는 섹션 33.8.3.2를 참조하십시오.

#### Multi-packet Instructions or Events

인터럽트(방해?)들 또는 태스크 스위치들과 같은 일부 동작들은 다수의 패킷들을 생성합니다. 이러한 경우들에서, 동작에서 각각의 CYC-지원 패킷들보다 앞서, 다수의 CYC 패킷들이 동작을 위해 전송될 수 있습니다. 소프트웨어 인터럽트 상의 태스크 스위치를 사용하는 예는 아래에 보여집니다.

### 33.3.6.3 Cycle Thresholds

소프트웨어는 정밀도를 희생하면서 대역폭과 침입을 절약하기 위한 트레이드오프인 사이클 패킷의 빈도를 줄이는 방법을 선택할 수 있습니다(섹션 33.2.8.2 참조). IA32_RTIT_CTL.CycThresh는 다음 CYC 패킷이 전송되기 전에 통과해야 하는 최소 사이클 수를 프로세서에 나타냅니다. 이 값이 0이면 threshold(임계값)가 사용되지 않으며, CYC 패킷은 CYC 지원 패킷이 생성되는 매 사이클마다 전송될 수 있습니다. 이 값이 0보다 크면 하드웨어는 다른 CYC 패킷을 보내기 전에 마지막 CYC 패킷 이후의 관련 사이클 수가 경과할 때까지 대기합니다. CPUID는 CycThresh에 대한 threshold(임계값) 옵션을 제공합니다(섹션 33.3.1 참조).

Cycle Threshold는 CYC 패킷이 게시되는 빈도를 결정하는 것이 아니라 최대 주파수를 할당하는 것에 불과합니다. Cycle threshold가 16인 경우, CYC 패킷은 16 사이클마다 보다 더 자주 포스팅되지 않을 수 있습니다. 그러나, 일단 그 16 사이클의 threshold(임계값)가 지난 후에도, CYC가 삽입되기 전에 새로운 CYC 지원 패킷이 생성될 것을 요구합니다. 표 33-13이 임계값 동작을 설명합니다.